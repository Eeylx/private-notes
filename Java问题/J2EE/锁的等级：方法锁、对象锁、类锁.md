# 方法锁（synchronized修饰方法时）

通过在方法声明中加入synchronized关键字来声明synchronized方法。synchronized方法控制对类成员变量的访问：

每个类实例对应一把锁，每个synchronized方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。**这种机制确保了同一时刻对于每一个类实例，其所有声明为synchronized的成员函数中至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。**

# 对象锁（synchronized修饰方法或代码块）

当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放。（方法锁也是对象锁）

Java的所有对象都含有一个互斥锁，这个锁由JVM自动获取和释放。线程进入synchronized方法的时候获取该对象的锁。synchronized方法正常返回或者抛异常终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的1个好处，方法抛异常的时候，锁仍然可以由JVM来自动释放。

# 类锁（synchronized修饰静态方法或代码块）

由于一个class不论被实例化多少次，其中的静态变量在内存中都只有一份，所以，一旦一个静态的方法被声明为synchronized，此类所有的实例化对象在调用此方法时，共用一把锁，我们称之为类锁。

对象所使用来控制实例方法之间的同步，类锁是用来控制静态方法（或静态变量互斥体）之间的同步。